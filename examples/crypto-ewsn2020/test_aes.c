/*
 * Copyright (C) 2020 HAW Hamburg
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     examples
 * @{
 *
 * @file
 * @brief       Application to measure AES CTR and CBC runtime
 *
 * @author      Lena Boeckmann <lena.boeckmann@haw-hamburg.de>
 *
 * @}
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "crypto/aes.h"
#include "crypto/ciphers.h"

#include "periph/gpio.h"
#include "xtimer.h"

#define ENABLE_DEBUG    (0)
#include "debug.h"

/* AES Test */
#if AES_CBC || AES_CTR || AES_ECB || TEST_AES_ECB_PARALLEL
    static uint8_t KEY[] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    };
    static uint8_t KEY_LEN = 16;

#endif

#ifdef AES_CBC

    static uint8_t CBC_IV[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
#ifndef INPUT_512
    static uint8_t __attribute__((aligned)) CBC_PLAIN[] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
    };
    static uint8_t CBC_PLAIN_LEN = 32;

    static uint8_t __attribute__((aligned)) CBC_CIPHER[] = {
        0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
        0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
        0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
        0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2
    };
    static uint8_t CBC_CIPHER_LEN = 32;
#else
    static unsigned char CBC_PLAIN[] = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Ste";
    #define CBC_PLAIN_LEN 512

    static uint8_t __attribute__((aligned)) CBC_CIPHER[] = {
        0xfa, 0xf4, 0x41, 0xbb, 0x79, 0x4a, 0x7a, 0x3e,
        0x27, 0x4f, 0x28, 0x6d, 0x11, 0x25, 0x7b, 0xc0,
        0xb8, 0x36, 0xab, 0x12, 0x1c, 0xd3, 0x5c, 0x3f,
        0x95, 0x3a, 0x55, 0x02, 0x36, 0x00, 0x5d, 0x12,
        0x80, 0x93, 0xf5, 0x53, 0xf1, 0xa3, 0x3a, 0x7c,
        0xac, 0x2f, 0x47, 0xe6, 0x85, 0x9b, 0xcd, 0x9f,
        0xfb, 0x8e, 0x22, 0xdd, 0xb3, 0xc0, 0x4c, 0x4f,
        0x7c, 0x26, 0x2b, 0x05, 0x4b, 0x21, 0x98, 0x53,
        0x1d, 0x09, 0x42, 0x90, 0x1f, 0x51, 0x44, 0x70,
        0xa6, 0xde, 0x84, 0x45, 0x6b, 0xb6, 0x71, 0x7f,
        0xc7, 0x83, 0x7c, 0x15, 0x8f, 0x1b, 0x9e, 0x47,
        0x0a, 0x41, 0xe6, 0x6c, 0x90, 0xf9, 0x37, 0x08,
        0xa5, 0x12, 0x38, 0x34, 0x46, 0x30, 0xc8, 0x47,
        0xaa, 0x77, 0x82, 0xd7, 0xda, 0xa7, 0x31, 0xcb,
        0xdc, 0x7c, 0xae, 0x2b, 0x69, 0xa7, 0xa1, 0x7a,
        0xd2, 0x87, 0x85, 0x82, 0xcd, 0xf0, 0xb2, 0x1b,
        0x11, 0x84, 0x65, 0x0a, 0x73, 0xad, 0x63, 0xff,
        0x62, 0x64, 0xfd, 0x95, 0x83, 0x97, 0x66, 0x91,
        0xac, 0xc1, 0x4f, 0x2f, 0xfe, 0xbc, 0xd4, 0xdd,
        0xe2, 0x75, 0xbd, 0x96, 0xa9, 0xb2, 0x85, 0x8b,
        0xe2, 0xe7, 0x95, 0x98, 0x66, 0x64, 0x1f, 0x75,
        0x07, 0x39, 0x56, 0x7f, 0x31, 0xc2, 0xe6, 0x6e,
        0x9b, 0xf0, 0xf9, 0x24, 0xc0, 0xae, 0x98, 0x19,
        0x71, 0x35, 0x81, 0x85, 0xf9, 0x1f, 0x50, 0xc1,
        0x9c, 0x83, 0xac, 0x95, 0x19, 0x9f, 0x4c, 0x65,
        0x93, 0x67, 0x7d, 0x04, 0xf1, 0x73, 0x89, 0x06,
        0xeb, 0xf3, 0xf2, 0x15, 0xc7, 0xf0, 0xf1, 0xcc,
        0x96, 0xed, 0x09, 0xa2, 0xaf, 0x36, 0x5d, 0x5b,
        0x9f, 0x8b, 0xb2, 0x4e, 0x0d, 0x7d, 0x4c, 0x19,
        0xcd, 0x36, 0xaf, 0x45, 0xfd, 0x3f, 0x03, 0xca,
        0x96, 0x15, 0x79, 0xd0, 0x6a, 0x8c, 0x2b, 0xc8,
        0xb1, 0x45, 0x49, 0x8f, 0x96, 0xa0, 0x2c, 0xa2,
        0x04, 0xa2, 0x98, 0xa3, 0xa0, 0xce, 0x15, 0x00,
        0x64, 0xeb, 0x81, 0x9f, 0xdb, 0xd8, 0x28, 0x83,
        0xc4, 0x1b, 0x83, 0x77, 0x59, 0x7d, 0x5f, 0x33,
        0x23, 0x95, 0x29, 0x8b, 0x3a, 0x1f, 0xff, 0x5a,
        0x4d, 0xe3, 0x6f, 0xd4, 0x99, 0xbe, 0x7a, 0x6b,
        0x3d, 0x6c, 0x5b, 0x3e, 0x2a, 0xd0, 0x8a, 0x50,
        0x65, 0xd1, 0xba, 0xcc, 0xa9, 0x17, 0xcd, 0xbd,
        0xb7, 0xd3, 0xf2, 0x39, 0x20, 0xb2, 0x3e, 0xb3,
        0x69, 0x08, 0x80, 0xdd, 0x81, 0x01, 0xad, 0xb3,
        0xd5, 0x34, 0x2a, 0x99, 0x8c, 0x33, 0x9a, 0xf9,
        0x37, 0xd6, 0x4b, 0x39, 0x9e, 0xc0, 0x77, 0x9a,
        0x20, 0xf3, 0xd0, 0x98, 0xdc, 0x35, 0x18, 0xde,
        0x04, 0xa5, 0x70, 0x59, 0x2f, 0x5b, 0xca, 0x94,
        0x76, 0x8e, 0xb8, 0x03, 0x4b, 0x90, 0x69, 0x5f,
        0x70, 0x94, 0xe7, 0x05, 0x7b, 0x09, 0xbc, 0x3c,
        0x4b, 0x14, 0xa1, 0x87, 0x82, 0x42, 0xaa, 0x2c,
        0x24, 0xe3, 0xaf, 0x19, 0x3d, 0x50, 0xfa, 0xff,
        0xd2, 0x98, 0xef, 0xa3, 0x5b, 0x37, 0x9b, 0xda,
        0x07, 0x7b, 0x04, 0x5c, 0xb2, 0x47, 0x9d, 0x42,
        0xc1, 0xc5, 0xdf, 0x75, 0xec, 0x38, 0x74, 0x3e,
        0xaf, 0xf4, 0x30, 0x90, 0x1b, 0x1a, 0x45, 0x82,
        0x7d, 0x7e, 0xf8, 0x22, 0x4d, 0x3e, 0xac, 0x37,
        0x03, 0x10, 0x29, 0x50, 0x29, 0x68, 0x70, 0xf9,
        0xd1, 0xd6, 0x35, 0xd7, 0xdc, 0x1d, 0x52, 0x08,
        0x72, 0x51, 0x61, 0x94, 0x96, 0x56, 0xa6, 0xfd,
        0x63, 0xaa, 0x99, 0x08, 0xc1, 0xd7, 0x37, 0x73,
        0x0f, 0x9d, 0xa6, 0x7e, 0xe5, 0x9e, 0x53, 0x21,
        0xa2, 0x89, 0xd0, 0x4b, 0x33, 0xf9, 0x9f, 0x6a,
        0x02, 0x47, 0x41, 0x95, 0x83, 0x8c, 0x15, 0x5a,
        0xcb, 0x80, 0xad, 0x5b, 0x1a, 0x5f, 0xbe, 0xc9,
        0xca, 0xd2, 0xd5, 0xdf, 0x5d, 0x7f, 0x56, 0x76,
        0xfd, 0x74, 0x39, 0x94, 0x70, 0x28, 0x85, 0x1c
    };
    #define CBC_CIPHER_LEN 512


#endif /* INPUT_512 */

    void aes_cbc_test(gpio_t active_gpio)
    {
        int ret;
        cipher_context_t ctx;
        uint8_t data[CBC_PLAIN_LEN];
        memset(data, 0, CBC_PLAIN_LEN);

        xtimer_sleep(1);
        for(int i=0;i<TEST_ENERGY_ITER;i++) {
            printf("Iteration %i/%i\n", i, TEST_ENERGY_ITER);

            gpio_set(active_gpio);
            ret = aes_init(&ctx, KEY, KEY_LEN);
            gpio_clear(active_gpio);
            if (ret < 1) {
                printf("AES CBC Enc Init failed: %d\n", ret);
                return;
            }

            gpio_set(active_gpio);
            ret = aes_encrypt_cbc(&ctx, CBC_IV, CBC_PLAIN, CBC_PLAIN_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES CBC Encrypt failed: %d\n", ret);
                return;
            }

            if (memcmp(data, CBC_CIPHER, CBC_CIPHER_LEN)) {
                printf("AES CBC encryption wrong cipher\n");
                // return;
            }

            gpio_set(active_gpio);
            ret = aes_decrypt_cbc(&ctx, CBC_IV, CBC_CIPHER, CBC_CIPHER_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES CBC Decrypt failed: %d\n", ret);
                return;
            }

            if (memcmp(data, CBC_PLAIN, CBC_CIPHER_LEN)) {
                printf("AES CBC decryption wrong plain text\n");
                return;
            }
            else {
                puts("SUCCESS");
            }
        }
        printf("AES CBC encrypt/decrypt done\n");
    }
#endif /* AES_CBC */

#ifdef AES_CTR
    static uint8_t CTR_COUNTER[16] = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    };
    static uint8_t CTR_COUNTER_LEN = 16;

#ifndef INPUT_512
    static uint8_t __attribute__((aligned)) CTR_PLAIN[] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
    };
    static uint8_t CTR_PLAIN_LEN = 32;

    static uint8_t CTR_CIPHER[] = {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff
    };
    static uint8_t CTR_CIPHER_LEN = 32;

#endif /* INPUT_512 */

    void aes_ctr_test(gpio_t active_gpio)
    {
        int ret;
        cipher_context_t ctx;
        uint8_t ctr[CTR_COUNTER_LEN];
        memcpy(ctr, CTR_COUNTER, CTR_COUNTER_LEN);
#ifdef INPUT_512
        uint8_t data_enc[PLAIN_LEN];
        uint8_t data_dec[PLAIN_LEN];
        memset(data_enc, 0, PLAIN_LEN);
        memset(data_dec, 0, PLAIN_LEN);
#else
        uint8_t data[CTR_PLAIN_LEN];
        memset(data, 0, CTR_PLAIN_LEN);
#endif /* INPUT_512 */

        gpio_set(active_gpio);
        ret = aes_init(&ctx, KEY, KEY_LEN);
        gpio_clear(active_gpio);
        if (ret < 1) {
            printf("AES CTR Init failed: %d\n", ret);
            return;
        }

#ifdef INPUT_512
        gpio_set(active_gpio);
        ret = aes_encrypt_ctr(&ctx, ctr, 0, CTR_PLAIN, CTR_PLAIN_LEN, data_enc);
        gpio_clear(active_gpio);

        if (ret < 0) {
            printf("AES CTR Enryption failed: %d\n", ret);
            return;
        }
        memcpy(ctr, CTR_COUNTER, CTR_COUNTER_LEN);

        gpio_set(active_gpio);
        ret = aes_decrypt_ctr(&ctx, ctr, 0, data_enc, CTR_CIPHER_LEN, data_dec);
        gpio_clear(active_gpio);

        if (ret < 0) {
            printf("AES CTR Decryption failed: %d\n", ret);
            return;
        }
#else
        gpio_set(active_gpio);
        ret = aes_encrypt_ctr(&ctx, ctr, 0, CTR_PLAIN, CTR_PLAIN_LEN, data);
        gpio_clear(active_gpio);

        if (ret < 0) {
            printf("AES CTR Enryption failed: %d\n", ret);
            return;
        }

        if (memcmp(data, CTR_CIPHER, CTR_CIPHER_LEN)) {
            printf("AES CTR encryption wrong cipher\n");
            return;
        }

        memset(data, 0, CTR_CIPHER_LEN);
        memcpy(ctr, CTR_COUNTER, CTR_COUNTER_LEN);

        gpio_set(active_gpio);
        ret = aes_decrypt_ctr(&ctx, ctr, 0, CTR_CIPHER, CTR_CIPHER_LEN, data);
        gpio_clear(active_gpio);

        if (ret < 0) {
            printf("AES CTR Decryption failed: %d\n", ret);
            return;
        }
        if (memcmp(data, CTR_PLAIN, CTR_CIPHER_LEN)) {
            printf("AES CTR decryption wrong plain text\n");
            return;
        }
#endif /* INPUT_512 */
        printf("AES CTR encrypt/decrypt done\n");
    }
#endif /* AES_CTR */

#if defined(AES_ECB) || defined(TEST_AES_ECB_PARALLEL)

#ifndef INPUT_512
    // static uint8_t __attribute__((aligned)) ECB_PLAIN[] = {
    //     0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    //     0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
    // };
    // static uint8_t ECB_PLAIN_LEN = 16;
    static uint8_t __attribute__((aligned)) ECB_PLAIN[] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
    };
    static uint8_t ECB_PLAIN_LEN = 32;

    // static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
    //     0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
    //     0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
    // };
    // static uint8_t ECB_CIPHER_LEN = 16;

    static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
    };
    static uint8_t ECB_CIPHER_LEN = 32;
#else
    static const unsigned char ECB_PLAIN[] = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Ste";
    static size_t ECB_PLAIN_LEN = 512;

    static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
        0xbf, 0xd7, 0x5c, 0xff, 0xc4, 0x2c, 0x4d, 0xf8,
        0xc7, 0xd6, 0xfa, 0x0e, 0x71, 0x5b, 0xae, 0xdb,
        0x0f, 0x0c, 0xe6, 0xb8, 0xac, 0x10, 0x27, 0x90,
        0xbf, 0xd7, 0x80, 0x78, 0xf2, 0x6e, 0x87, 0x05,
        0x25, 0x9b, 0x53, 0x92, 0xa7, 0x2c, 0x73, 0x7c,
        0x9d, 0x90, 0x51, 0x2d, 0x02, 0x39, 0xdd, 0x7d,
        0xc3, 0x8a, 0x0d, 0xc4, 0xbe, 0x88, 0x32, 0xc0,
        0xc8, 0xac, 0xa5, 0x06, 0x41, 0x09, 0x75, 0xb7,
        0xcd, 0xc9, 0xc1, 0x5d, 0xc6, 0x6c, 0xae, 0xb6,
        0xfd, 0x44, 0x76, 0x79, 0x5a, 0x9a, 0x02, 0xe0,
        0x35, 0xbf, 0x5b, 0xb4, 0xbb, 0xe9, 0x60, 0xa8,
        0x52, 0x40, 0x01, 0xf8, 0xcc, 0x03, 0x33, 0xc9,
        0x51, 0x46, 0x12, 0xe6, 0x48, 0x35, 0x26, 0xd9,
        0x49, 0x7e, 0x07, 0xa2, 0x2f, 0xb3, 0x6a, 0x22,
        0x7b, 0x9f, 0xab, 0x81, 0xc8, 0x3f, 0x73, 0xb6,
        0x4f, 0x6d, 0xd3, 0xe3, 0x77, 0xf2, 0xdd, 0xfe,
        0x65, 0xa5, 0xb2, 0xcf, 0x5a, 0x9e, 0xa8, 0xbe,
        0x37, 0x8a, 0x2e, 0x49, 0x87, 0xf6, 0x4d, 0xf8,
        0x0b, 0x05, 0x55, 0x32, 0xac, 0x75, 0xe1, 0x70,
        0x1b, 0xee, 0x8e, 0x44, 0x8c, 0xba, 0xfe, 0xff,
        0xc4, 0x72, 0xe2, 0x1d, 0x43, 0x3d, 0x09, 0x94,
        0x35, 0x68, 0x1f, 0x53, 0xb4, 0x9e, 0x1e, 0x36,
        0x08, 0xc1, 0x6c, 0xe8, 0x05, 0x6a, 0x9b, 0xc6,
        0xc1, 0x93, 0x37, 0x1d, 0x71, 0x0f, 0x39, 0x1f,
        0xb4, 0x21, 0x5c, 0x03, 0x5b, 0x7c, 0x63, 0x30,
        0xa3, 0x75, 0x06, 0xb2, 0xbf, 0x6b, 0x6a, 0x99,
        0x65, 0xfa, 0xab, 0xd3, 0x09, 0xaf, 0x6c, 0x3e,
        0x10, 0xbe, 0x2f, 0x8d, 0xff, 0x21, 0x76, 0x40,
        0x48, 0xfe, 0x0b, 0x13, 0xc8, 0xe8, 0x8d, 0x9e,
        0xea, 0x9d, 0x41, 0xa0, 0x3f, 0xc7, 0xe2, 0xa4,
        0x8f, 0xca, 0xe0, 0xbb, 0x6f, 0x9a, 0x43, 0x2d,
        0xcd, 0xc7, 0x92, 0xf3, 0x14, 0xf7, 0x61, 0xfd,
        0x10, 0x91, 0x4c, 0x13, 0xb0, 0x89, 0x9d, 0x58,
        0x50, 0x2f, 0xf0, 0x90, 0x9a, 0xce, 0x41, 0x39,
        0x77, 0x28, 0x3c, 0x25, 0x2d, 0x43, 0x65, 0x36,
        0x05, 0x5c, 0x39, 0xfe, 0xc2, 0xcf, 0x9c, 0x81,
        0x9c, 0xe0, 0xe5, 0xa0, 0xc8, 0x87, 0x80, 0x14,
        0x65, 0x4c, 0x5d, 0xa9, 0xaf, 0x7d, 0xfb, 0x60,
        0x1e, 0xc7, 0x56, 0x83, 0xfa, 0xfd, 0x95, 0x56,
        0x2f, 0xa1, 0x7b, 0x90, 0x13, 0x8e, 0x32, 0x84,
        0xe6, 0x46, 0xc6, 0x76, 0x8f, 0x7d, 0x10, 0x53,
        0x13, 0x28, 0x0b, 0x8a, 0x4b, 0x88, 0xe7, 0x19,
        0x0b, 0x1e, 0xa1, 0x37, 0x1a, 0xef, 0x01, 0x54,
        0x69, 0x90, 0x82, 0x8d, 0x43, 0x5a, 0x5e, 0xb7,
        0xda, 0x6d, 0x5e, 0x0b, 0xcf, 0x22, 0x75, 0xb7,
        0x14, 0xa5, 0xb2, 0x80, 0x7d, 0x22, 0xba, 0x2b,
        0xe2, 0x2b, 0x8e, 0x48, 0x1c, 0xdc, 0x37, 0x9c,
        0x1c, 0xb4, 0xd3, 0xf1, 0x03, 0xeb, 0x06, 0xdf,
        0x18, 0xed, 0xbc, 0x09, 0x64, 0x11, 0x45, 0x26,
        0xb6, 0xd3, 0x59, 0x01, 0xb6, 0x82, 0xcf, 0x41,
        0xcd, 0x38, 0x1d, 0xa3, 0xb9, 0xc3, 0x1c, 0x14,
        0xa0, 0x0a, 0x7f, 0x96, 0x48, 0x90, 0x1f, 0xb5,
        0xb6, 0xbb, 0x68, 0x42, 0x63, 0x9e, 0xca, 0x09,
        0xb6, 0xf1, 0x79, 0xa5, 0x69, 0xc8, 0x5e, 0x28,
        0xc0, 0xdd, 0x69, 0xe3, 0xd9, 0x40, 0x3f, 0xf6,
        0xcf, 0xc7, 0x27, 0x93, 0x32, 0x50, 0x1d, 0x87,
        0x25, 0xad, 0xb5, 0xc8, 0x16, 0xfa, 0x47, 0x60,
        0xe7, 0x00, 0x88, 0xc6, 0x01, 0xa7, 0xa2, 0xd7,
        0x1d, 0xbd, 0xfe, 0x5f, 0xbb, 0x00, 0x42, 0xd5,
        0x31, 0xba, 0xdc, 0x59, 0x3c, 0xa4, 0xcb, 0x56,
        0x1d, 0x3c, 0xbc, 0x36, 0x9e, 0x88, 0x55, 0xca,
        0xef, 0x5b, 0xce, 0xbe, 0xd8, 0x2e, 0x32, 0x6c,
        0x11, 0x3b, 0x1d, 0xc5, 0x4e, 0x20, 0x6e, 0x48,
        0x72, 0x52, 0x07, 0xc1, 0x62, 0x09, 0x37, 0x50
        };
    #define ECB_CIPHER_LEN 512
#endif /* INPUT_512 */
#endif /* AES_ECB || TEST_AES_ECB_PARALLEL */

#ifdef AES_ECB
    void aes_ecb_test(gpio_t active_gpio)
    {
        int ret;
        cipher_context_t ctx;
        uint8_t data[ECB_PLAIN_LEN];
        memset(data, 0, ECB_PLAIN_LEN);

        xtimer_sleep(1);
        for(int i=0;i<TEST_ENERGY_ITER;i++) {
            printf("Iteration %i/%i\n", i, TEST_ENERGY_ITER);

            gpio_set(active_gpio);
            ret = aes_init(&ctx, KEY, KEY_LEN);
            gpio_clear(active_gpio);
            if (ret < 1) {
                printf("AES Init failed: %d\n", ret);
            }

            gpio_set(active_gpio);
            ret = aes_encrypt_ecb(&ctx, ECB_PLAIN, ECB_PLAIN_LEN, data);
            gpio_clear(active_gpio);
            if (ret < 0) {
                printf("AES ECB Enryption failed: %d\n", ret);
                return;
            }

            // memset(data, 0, ECB_CIPHER_LEN);

            gpio_set(active_gpio);
            ret = aes_decrypt_ecb(&ctx, ECB_CIPHER, ECB_CIPHER_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES ECB Deryption failed: %d\n", ret);
                return;
            }

            if (memcmp(data, ECB_PLAIN, ECB_PLAIN_LEN)) {
                printf("AES ECB decryption wrong plain\n");
                return;
            }
            else {
                puts("success");
            }
        }

        printf("AES ECB encrypt/decrypt done\n");
    }
#endif /* AES_ECB */

#ifdef TEST_AES_ECB_PARALLEL

#include "thread.h"

#ifndef TEST_AES_ECB_PARALLEL_ITER
#define TEST_AES_ECB_PARALLEL_ITER 1000
#endif

typedef struct {
    gpio_t *pin;
    const char* name;
} thread_info_t;

char aes_ecb_thread_1_stack[THREAD_STACKSIZE_MAIN];
char aes_ecb_thread_2_stack[THREAD_STACKSIZE_MAIN];

void *aes_ecb_thread(void *arg)
{
    thread_info_t *info = (thread_info_t *)arg;
    gpio_t *pin = info->pin;
    int ret;
    (void) ECB_CIPHER;
    (void) ECB_CIPHER_LEN;
    (void) ECB_PLAIN;
    (void) ret;
    (void) pin;
    cipher_context_t ctx;
    uint8_t data[ECB_PLAIN_LEN];
    memset(data, 0, ECB_PLAIN_LEN);

    printf("=======[%s]: START========\n", info->name);
    aes_init(&ctx, KEY, KEY_LEN);

    for (unsigned i = 0; i < 1000; i++) {
        gpio_set(*pin);
        ret = aes_encrypt_ecb(&ctx, ECB_PLAIN, ECB_PLAIN_LEN, data);
        gpio_clear(*pin);

        if (ret < 0) {
            printf("AES ECB Enryption failed: %d\n", ret);
            return NULL;
        }
    }

    printf("=======[%s]: DONE========\n", info->name);

    return NULL;
}

thread_info_t info1 = {
    .pin = NULL,
    .name = "Thread 1"
};

thread_info_t info2 = {
    .pin = NULL,
    .name = "Thread 2"
};

void aes_ecb_parallel_test(gpio_t *thread1_pin, gpio_t *thread2_pin)
{
    gpio_init(*thread1_pin, GPIO_OUT);
    gpio_clear(*thread1_pin);
    gpio_init(*thread2_pin, GPIO_OUT);
    gpio_clear(*thread2_pin);

    info1.pin = thread1_pin;
    info2.pin = thread2_pin;

    xtimer_sleep(1);

    thread_create(aes_ecb_thread_1_stack, sizeof(aes_ecb_thread_1_stack),
                  THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST,
                  aes_ecb_thread, &info1, "AES ECB 1");

    thread_create(aes_ecb_thread_2_stack, sizeof(aes_ecb_thread_2_stack),
                  THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST,
                  aes_ecb_thread, &info2, "AES ECB 2");
}

#endif /* TEST_AES_ECB_PARALLEL */
